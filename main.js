/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalendarEventPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var PLUGIN_NAME = "MyTicker";
var DEFAULT_SETTINGS = {
  prefixName: "event",
  timeStart: "9h",
  timeDuration: "1h",
  days: [],
  recurrenceInterval: 1
};
var CalendarEventPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.ribbonIcon = this.addRibbonIcon("calendar-heart", `${PLUGIN_NAME}: Create Ticks`, (evt) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) {
        new import_obsidian.Notice("No active note found!");
        return;
      }
      const editor = activeView.editor;
      const file = activeView.file;
      if (!editor || !file) {
        notice("Cannot access editor or file!");
        return;
      }
      new EventCreationModal(
        this.app,
        this.settings,
        async (result) => {
          if (!result)
            return;
          await this.saveSettings(result);
          await this.createEvents(result, file);
        }
      ).open();
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings(data) {
    const settings = {
      prefixName: data.prefixName,
      timeStart: data.timeStart,
      timeDuration: data.timeDuration,
      days: data.days,
      recurrenceInterval: data.recurrenceInterval
    };
    this.settings = settings;
    await this.saveData(settings);
  }
  async createEvents(params, file) {
    try {
      const events = this.generateEvents(params);
      if (events.length === 0) {
        new import_obsidian.Notice("No events generated for the selected period!");
        return;
      }
      let eventText = "";
      let index = 0;
      for (let event of events) {
        eventText += `- [t::${event.prefixName}_${++index},${event.date},${event.timeStart},${event.timeDuration}]
`;
      }
      const content = await this.app.vault.read(file);
      const newContent = content + "\n\n" + eventText;
      await this.app.vault.modify(file, newContent);
      notice(`Created ${events.length} calendar events!`);
    } catch (error) {
      notice("Error creating events: " + error.message);
      console.error(error);
    }
  }
  generateEvents(params) {
    const events = [];
    let currentDate = (0, import_obsidian.moment)(params.startInterval);
    const endDate = (0, import_obsidian.moment)(params.endInterval);
    while (currentDate.isSameOrBefore(endDate)) {
      const currentWeek = currentDate.isoWeek();
      const startWeek = (0, import_obsidian.moment)(params.startInterval).isoWeek();
      const weekDiff = currentWeek - startWeek;
      if (params.days.includes(currentDate.day()) && weekDiff % params.recurrenceInterval === 0) {
        const event = {
          prefixName: params.prefixName,
          date: currentDate.format("YYYY-MM-DD"),
          timeStart: params.timeStart,
          timeDuration: params.timeDuration
        };
        events.push(event);
      }
      currentDate = currentDate.add(1, "day");
    }
    return events;
  }
};
var EventCreationModal = class extends import_obsidian.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create Calendar Events" });
    let prefixName = this.settings.prefixName;
    let timeStart = this.settings.timeStart;
    let timeDuration = this.settings.timeDuration;
    let days = this.settings.days;
    let recurrenceInterval = this.settings.recurrenceInterval;
    new import_obsidian.Setting(contentEl).setName("Prefix Name").setDesc('Base name for events (e.g., "meeting", "class")').addText((text) => text.setValue(prefixName).onChange((value) => prefixName = value));
    new import_obsidian.Setting(contentEl).setName("Start Time").setDesc("Event start time (12h)").addText((text) => text.setValue(timeStart).setPlaceholder("12h30m").onChange((value) => timeStart = value));
    new import_obsidian.Setting(contentEl).setName("Duration").setDesc("Event duration (1h30m)").addText((text) => text.setValue(timeDuration).setPlaceholder("15m").onChange((value) => timeDuration = value));
    const startDateSetting = new import_obsidian.Setting(contentEl).setName("Start Date").setDesc("Select start date for events");
    const startDateContainer = startDateSetting.descEl.createDiv({ cls: "date-picker-container" });
    const startDateInput = startDateContainer.createEl("input", {
      type: "date",
      cls: "date-picker"
    });
    startDateInput.value = (0, import_obsidian.moment)().format("YYYY-MM-DD");
    const endDateSetting = new import_obsidian.Setting(contentEl).setName("End Date").setDesc("Select end date for events");
    const endDateContainer = endDateSetting.descEl.createDiv({ cls: "date-picker-container" });
    const endDateInput = endDateContainer.createEl("input", {
      type: "date",
      cls: "date-picker"
    });
    endDateInput.value = (0, import_obsidian.moment)().add(7, "d").format("YYYY-MM-DD");
    endDateInput;
    const weekIntervalSetting = new import_obsidian.Setting(contentEl).setName("Week Interval").setDesc("Repeat every X weeks").addText((text) => text.setValue(recurrenceInterval.toString() || "1").onChange(
      (value) => {
        const numValue = parseInt(value);
        if (isNaN(numValue) || numValue < 1 && numValue >= 100) {
          notice("Error: Week Interval: Must be in [1,100]");
          recurrenceInterval = 0;
        }
        recurrenceInterval = numValue;
      }
    ));
    const daysContainer = contentEl.createDiv();
    daysContainer.createEl("p", { text: "Select days:" });
    const daysMapping = [
      { value: 1, label: "M", fullName: "Mon" },
      { value: 2, label: "T", fullName: "Tue" },
      { value: 3, label: "W", fullName: "Wed" },
      { value: 4, label: "T", fullName: "Thu" },
      { value: 5, label: "F", fullName: "Fri" },
      { value: 6, label: "S", fullName: "Sat" },
      { value: 0, label: "S", fullName: "Sun" }
    ];
    const daysGrid = daysContainer.createDiv({ cls: "days-of-week-container" });
    for (let day of daysMapping) {
      const dayDiv = daysGrid.createDiv({ cls: "day-circle" });
      const checkbox = dayDiv.createEl("input", {
        type: "checkbox",
        cls: "day-check"
      });
      checkbox.checked = days.includes(day.value);
      const label = dayDiv.createEl("label", {
        cls: "day-circle-label",
        text: day.label
      });
      dayDiv.createEl("div", {
        cls: "day-name",
        text: day.fullName
      });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          if (!days.includes(day.value)) {
            days.push(day.value);
          }
        } else {
          days = days.filter((d) => d !== day.value);
        }
      });
      dayDiv.addEventListener("click", (e) => {
        if (e.target !== checkbox) {
          checkbox.checked = !checkbox.checked;
          checkbox.dispatchEvent(new Event("change"));
        }
      });
    }
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText("Create Events").setCta().onClick(() => {
      const result = {
        prefixName,
        timeStart,
        timeDuration,
        days,
        recurrenceInterval,
        startInterval: new Date(startDateInput.value),
        endInterval: new Date(endDateInput.value)
      };
      this.onSubmit(result);
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function notice(message) {
  new import_obsidian.Notice(
    `${PLUGIN_NAME}: ${message}`
  );
}
